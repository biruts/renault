'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var elems = {};
var STICKY_CLASS = 'is-sticky';
var STICKY_ATTR = '__sticky';

var id = 0;

/**
 * Return the window scroll position.
 *
 * @return {{top: (Number|number), left: (Number|number)}}
 */
var getScrollPosition = function getScrollPosition() {
  return {
    top: window.pageYOffset || document.documentElement.scrollTop,
    left: window.pageXOffset || document.documentElement.scrollLeft
  };
};

/**
 * Makes an element sticky.
 *
 * @param elem
 * @param style
 */
var makeSticky = function makeSticky(elem, style) {
  elem[STICKY_ATTR] = id;
  elems[id] = {
    elem: elem,
    style: style,
    defaultRect: {
      top: elem.getBoundingClientRect().top + getScrollPosition().top
    }
  };

  id++;

  return elem;
};

/**
 * Make the element with given id sticky.
 *
 * @param _id
 */
var toSticky = function toSticky(_id) {
  var _elems$_id = elems[_id],
      elem = _elems$_id.elem,
      style = _elems$_id.style;

  elem.classList.add(STICKY_CLASS);

  var clone = elem.cloneNode(true);

  elems[_id].defaultVisibility = elem.style.visibility;
  elems[_id].defaultOpacity = elem.style.opacity;
  elems[_id].clone = clone;

  // Make the element invisible
  elem.style.visibility = 'hidden';
  elem.style.opacity = 0;

  // Then lets merge the style
  if (style) {
    Object.keys(style).forEach(function (key) {
      clone.style[key] = style[key];
    });
  }

  // Now lets make it sticky
  clone.style.position = 'fixed';
  clone.style.top = 0;

  elem.parentNode.insertBefore(clone, elem);
};

/**
 * Remove the sticky styles and classes from the element with given id.
 *
 * @param _id
 */
var toUnsticky = function toUnsticky(_id) {
  var _elems$_id2 = elems[_id],
      elem = _elems$_id2.elem,
      clone = _elems$_id2.clone,
      defaultVisibility = _elems$_id2.defaultVisibility,
      defaultOpacity = _elems$_id2.defaultOpacity;

  elem.classList.remove(STICKY_CLASS);
  elem.style.visibility = defaultVisibility;
  elem.style.opacity = defaultOpacity;
  clone.parentNode.removeChild(clone);
};

var listener = {
  /**
   * Start listening to scroll event.
   */
  init: function init() {
    window.addEventListener('scroll', listener.onScroll, false);
  },

  /**
   * Stop listening to scroll event.
   */
  stop: function stop() {
    window.removeEventListener('scroll', listener.onScroll, false);
  },

  /**
   * The listener function. This function will listen the scroll
   * event and it will loop through registered elements. If they
   * are in viewport, they will be made sticky. Otherwise left as
   * they were.
   */
  onScroll: function onScroll() {
    var scrollPos = getScrollPosition();

    Object.keys(elems).forEach(function (_id) {
      var _elems$_id3 = elems[_id],
          top = _elems$_id3.defaultRect.top,
          elem = _elems$_id3.elem;


      if (top <= scrollPos.top) {
        if (elem.classList.contains(STICKY_CLASS) === false) {
          toSticky(_id);
        }
      } else {
        if (elem.classList.contains(STICKY_CLASS)) {
          toUnsticky(_id);
        }
      }
    });
  }
};

var Sticky = {
  /**
   * Make the given elem sticky when elem scrolls out of viewport.
   *
   * @param {HTMLElement} elem
   * @param {Object} style Extra style to be merged
   * @returns {HTMLElement|void} Returns the element on success and void on failure.
   */
  sticky: function sticky(elem, style) {
    // In case we already have the elem already registered
    if (!elem || typeof elem[STICKY_ATTR] === 'number') {
      return;
    }

    if (Object.keys(elems).length === 0) {
      listener.init();
    }

    return makeSticky(elem, style);
  },

  /**
   * Return the element to initial state.
   *
   * @param {HTMLElement} elem div
   * @returns {HTMLElement|void} Returns the element on success and undefined on failure.
   */
  unsticky: function unsticky(elem) {
    var _id = elem && elem[STICKY_ATTR];

    if (!elem || typeof elems[_id] === 'undefined') {
      return;
    }

    delete elems[_id];
    delete elem[STICKY_ATTR];

    if (Object.keys(elems).length === 0) {
      listener.stop();
    }

    return elem;
  },

  /**
   * Make all active elements unsticky.
   */
  unstickyAll: function unstickyAll() {
    Object.keys(elems).forEach(function (k) {
      return Sticky.unsticky(elems[k].elem);
    });
  },

  /**
   * Return all active sticky elements.
   *
   * @return {Array}
   */
  all: function all() {
    return Object.keys(elems).map(function (k) {
      return elems[k].elem;
    });
  }
};

var sticky = Sticky.sticky;
var unsticky = Sticky.unsticky;
var unstickyAll = Sticky.unstickyAll;
var all = Sticky.all;

exports.sticky = sticky;
exports.unsticky = unsticky;
exports.unstickyAll = unstickyAll;
exports.all = all;
